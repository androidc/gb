#  <#Title#>

Выбор первого игрока  goToFirstState() 
переключение на state первого игрока
там begin - switch labels
потом addMark 1 -го
запись позиции для referree  gameBoard?.setPlayer(player, at: position)
Простановка марки gameBoardView.placeMarkView(markViewPrototype.copy(), at: position)
и completed = true
Потом переход на 2-го игрока


Перед переходом определение победителя
если есть winner или он не определен но игра закончена переход на GameEndedState
если нет победителя и игра не закончена, то переход на state следующего игрока и все по новой

в определении следующего можно вставить компуктер и везде добавить обработку .computer 

Второе задание на паттерн State.
Примечание: возможно, задания 2 и 3 вы решите делать вместе, поэтому прочтите их оба, прежде чем приступать к выполнению.
Изменим правила игры: теперь игроки ходят не по очереди, а сначала первый игрок указывает 5 клеток, в которые он ставит крестик, затем второй игрок указывает 5 клеток, куда он ставит нолик. Затем игра должна показать расстановку крестиков и ноликов в последовательности крестик — нолик — крестик — нолик — ... Иными словами, правила игры такие же, как раньше, только теперь каждый игрок должен вслепую заранее указать все свои 5 ходов. Если отметка одного игрока при этом накладывается на отметку другого (они же не знали ходы друг друга, так что такое возможно), то она сначала стирает предыдущую отметку и затем ставится в эту клетку. Когда пройдена последовательность ходов, игра определяет победителя.
Реализуйте такое поведение для игры между двумя живыми игроками, добавив еще одно состояние — состояние хода игрока, в котором игрок ставит все 5 отметок. Затем добавьте еще состояние исполнения игры. В нем игра должна последовательно показать ходы игроков, как если бы они шли в обычной игре в крестики-нолики. Затем должен определиться победитель (для этого можно использовать написанный на уроке код).

         goToFirstState()
         
                     gameboardView.onSelectPosition = { [weak self] position in
                guard let self = self else { return }
                
                
<!--                self.currentState.addMark(at: position)-->
<!--                if self.currentState.isCompleted {-->
<!--                     self.goToNextState()-->
<!--                }-->
                    self.currentState.addFiveMark(at: position)
                    if self.currentState.isCompleted {
                         self.goToNextStateOfFive()           
                    }

        }

в  addFiveMark isCompleted = true когда проставлены 5 марок
в goToNextStateOfFive мы проверяем победителя после того, как второй игрок сделает 5 марок


3. Задание на паттерн Command.
Ход игрока представьте в виде команды. Recievers (получатели) у нас уже есть — это объект доски и ее view. Подумайте, кто будет являться invoker’ом. Подсказка: для него лучше создать отдельный объект. Команду инициализируйте с информацией об игроке, позиции и доске. В команду добавьте метод execute(), в котором будет обращение к receiver’ам: добавить отметку на доску, отрисовать ее. PlayerInputState измените так, чтобы когда юзер тапает на клетку, он вызывал добавление команды invoker’у. Когда все ходы расставлены, state исполнения игры сообщает invoker’у, что нужно исполнить все команды, и таким образом партия игры будет разыграна.
